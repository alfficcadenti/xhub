# Build System

## Production

In production, all code is served out of the `build` directory. This directory is generated by the `npm run build` task when the release is cut. Below is a desciption of the contents of the various directories and how they are produced.

#### `build/server`

Contains server-side code that has been transpiled with babel. We are not using webpack for server-side code. Transpiling alone keeps the directory structure in place and does not minify the code. Also, we are not transpiling all the way to es5, but rather transpiling to node's supported es6 features. Transpiling server-side code is not without it's downsides. The most critical is potential issues when debugging code through stack traces. While we are using source maps, it is possible some debugging fidelity is lost. We say possible, but so far it is looking good. We need to monitor this as we move forward, especially if we integrate more es-next features into server-side code.

#### `build/universal`

Code that produces the initial server-side rendered page. This is essentially what the client-side code would render, but rendered directly on the server when a user requests a page. The code has also been transpiled with babel so that it can be executed on the server, because of this, it too has the same potential issue raised in the section above.

#### `build/static`

Client-side assets. This includes images, minified CSS files, minified Javascript files, etc... The contents of this directory is produced by webpack. Ultimately these files will be sent to the CDN, and pages will request the assets directly from there.



## Development

In development, all code is served from the `src` directory and when executed on the server, is transpiled on-the-fly with babel running in a mode that allows for that. Code that is executed on the client is served from an in-memory file system produced by webpack, lets go through these items in detail.

When you run `npm start`, a fairly sophisticated process kicks off. Webpack piggybacks on the Hapi server and does an initial compilation of assets to an in-memory file system, then goes into "watch" mode.

Once the page is up in the browser, file changes will trigger webpack to re-compile the output bundle and since we have configured hot module replacement mode, MAGIC ENSUES. The browser is notified of the change. So instead of needing to manually refresh the page OR have it automatically refresh, webpack simply triggers a re-render of just the modules that have been affected by the code change. This means you can navigate into a particular state of the application, then make code changes without losing that state.

CSS is bundled with the JS, but only during development. Webpack includes a small lib that adds the CSS styles to a `<style>` tag on the page. In production, they are separate.

## How page requests are processed

1) Server code is executed. The initial page is rendered within node and a fully rendered page is served to the browser. By rendered, we mean, the HTML markup that is produced by the code is written to the response.

2) The browser receives the page and the DOM is created from the server-rendered markup.

3) The client-side javascript bundle is sent over the wire to the browser.

4) When the browser receives the JS bundle, react compares what has been rendered to the DOM with what is specified in the bundle. If there is a difference, it re-renders. Certain scenarios during development will get create these differences, see "Things to look out for" below. In production, there should never be differences between the two.

## Things to watch out for

### Development

1) You will likely see a flash of un-styled content while refreshing the page during development. The server code is rendered WITHOUT a synchronous CSS file load at the top of the document. Then when the webpack bundle is received by the browser, the CSS styles are added. This should not happen in production.

2) Server-side render out of sync with client-side render. When the node server is started, all server side code is cached by node. Then as you work on code within the `src/universal` directory, webpack's hot module replacement will show your changes in the browser. If you manually refresh, node will serve its cached code for the server-side render which will not reflect your new changes. A moment later the client-side render will notice there are differences and render the newest. You'll see a react warning in the browser console.

### Production

1) When errors occur, do stack traces match code in `src` dir? Line numbers should match. If not we may need to tweak the source map process.

2) We should never see a flash of un-styled content in non-development environments, but if we do, we would likely need to embed some styles in the server-rendered page response.
